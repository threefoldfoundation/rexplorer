package consensus

import (
	"fmt"

	"github.com/threefoldtech/rivine/modules"
	"github.com/threefoldtech/rivine/modules/consensus"
	"github.com/threefoldtech/rivine/types"
)

func GetStandardTransactionValidators() []modules.TransactionValidationFunction {
	return []modules.TransactionValidationFunction{
		consensus.ValidateTransactionFitsInABlock,
		consensus.ValidateTransactionArbitraryData,
		consensus.ValidateCoinInputsAreValid,
		consensus.ValidateCoinOutputsAreValid,
		consensus.ValidateBlockStakeInputsAreValid,
		consensus.ValidateBlockStakeOutputsAreValid,
		consensus.ValidateDoubleCoinSpends,
		consensus.ValidateDoubleBlockStakeSpends,
		consensus.ValidateCoinInputsAreFulfilled,
		consensus.ValidateBlockStakeInputsAreFulfilled,
	}
}

func GetStandardTransactionVersionMappedValidators() map[types.TransactionVersion][]modules.TransactionValidationFunction {
	const (
		minimumBlockHeightSinceMinerFeesAreRequired   = 300000
		blockHeightSinceLegacyTransactionsAreDisabled = 385000
	)
	validator := &MinimumMinerFeeValidator{MinimumBlockHeight: minimumBlockHeightSinceMinerFeesAreRequired}
	legacyValidator := &DisableTransactionSinceValidator{MinimumBlockHeight: blockHeightSinceLegacyTransactionsAreDisabled}
	return map[types.TransactionVersion][]modules.TransactionValidationFunction{
		types.TransactionVersionZero: {
			validator.Validate,
			legacyValidator.Validate,
			consensus.ValidateCoinOutputsAreBalanced,
			consensus.ValidateBlockStakeOutputsAreBalanced,
		},
		types.TransactionVersionOne: {
			validator.Validate,
			consensus.ValidateCoinOutputsAreBalanced,
			consensus.ValidateBlockStakeOutputsAreBalanced,
		},
	}
}

func GetTestnetTransactionValidators() []modules.TransactionValidationFunction {
	return []modules.TransactionValidationFunction{
		consensus.ValidateTransactionFitsInABlock,
		consensus.ValidateTransactionArbitraryData,
		consensus.ValidateCoinInputsAreValid,
		consensus.ValidateCoinOutputsAreValid,
		consensus.ValidateBlockStakeInputsAreValid,
		consensus.ValidateBlockStakeOutputsAreValid,
		consensus.ValidateDoubleCoinSpends,
		consensus.ValidateDoubleBlockStakeSpends,
		consensus.ValidateCoinInputsAreFulfilled,
		consensus.ValidateBlockStakeInputsAreFulfilled,
	}
}

func GetTestnetTransactionVersionMappedValidators() map[types.TransactionVersion][]modules.TransactionValidationFunction {
	const (
		minimumBlockHeightSinceMinerFeesAreRequired   = 300000
		blockHeightSinceLegacyTransactionsAreDisabled = 385000
	)
	validator := &MinimumMinerFeeValidator{MinimumBlockHeight: minimumBlockHeightSinceMinerFeesAreRequired}
	legacyValidator := &DisableTransactionSinceValidator{MinimumBlockHeight: blockHeightSinceLegacyTransactionsAreDisabled}
	return map[types.TransactionVersion][]modules.TransactionValidationFunction{
		types.TransactionVersionZero: {
			validator.Validate,
			legacyValidator.Validate,
			consensus.ValidateCoinOutputsAreBalanced,
			consensus.ValidateBlockStakeOutputsAreBalanced,
		},
		types.TransactionVersionOne: {
			validator.Validate,
			consensus.ValidateCoinOutputsAreBalanced,
			consensus.ValidateBlockStakeOutputsAreBalanced,
		},
	}
}

func GetDevnetTransactionValidators() []modules.TransactionValidationFunction {
	return []modules.TransactionValidationFunction{
		consensus.ValidateTransactionFitsInABlock,
		consensus.ValidateTransactionArbitraryData,
		consensus.ValidateCoinInputsAreValid,
		consensus.ValidateCoinOutputsAreValid,
		consensus.ValidateBlockStakeInputsAreValid,
		consensus.ValidateBlockStakeOutputsAreValid,
		consensus.ValidateMinerFeeIsPresent,
		consensus.ValidateMinerFeesAreValid,
		consensus.ValidateDoubleCoinSpends,
		consensus.ValidateDoubleBlockStakeSpends,
		consensus.ValidateCoinInputsAreFulfilled,
		consensus.ValidateBlockStakeInputsAreFulfilled,
	}
}

func GetDevnetTransactionVersionMappedValidators() map[types.TransactionVersion][]modules.TransactionValidationFunction {
	return map[types.TransactionVersion][]modules.TransactionValidationFunction{
		types.TransactionVersionZero: {
			consensus.ValidateInvalidByDefault, // no longer required to exist on devnet
		},
		types.TransactionVersionOne: {
			consensus.ValidateCoinOutputsAreBalanced,
			consensus.ValidateBlockStakeOutputsAreBalanced,
		},
	}
}

// MinimumMinerFeeValidator is a validator which allows to check
// the minimum miner fees (and whether they are available) only since a specific (block) height.
type MinimumMinerFeeValidator struct {
	MinimumBlockHeight types.BlockHeight
}

// Validate is a validator function that checks if all miner fees are valid.
// Until the minimum block height 0 fees are allowed, afterwards the minimum fee is checked
func (validator *MinimumMinerFeeValidator) Validate(tx modules.ConsensusTransaction, ctx types.TransactionValidationContext) error {
	if ctx.BlockHeight < validator.MinimumBlockHeight {
		// no need to check
		return nil
	}
	if ctx.IsBlockCreatingTx {
		return nil // validation does not apply to to block creation tx
	}
	if len(tx.MinerFees) == 0 {
		return fmt.Errorf("tx %s does not contain any miner fees while at least one was expected", tx.ID().String())
	}
	for _, fee := range tx.MinerFees {
		if fee.Cmp(ctx.MinimumMinerFee) == -1 {
			return types.ErrTooSmallMinerFee
		}
	}
	return nil
}

// DisableTransactionSinceValidator is a validator which allows to
// no longer allow a transaction since a specific block height
type DisableTransactionSinceValidator struct {
	MinimumBlockHeight types.BlockHeight
}

// Validate is a validator function that checks if the transaction is still allowed
// in the current chain.
func (validator *DisableTransactionSinceValidator) Validate(tx modules.ConsensusTransaction, ctx types.TransactionValidationContext) error {
	if ctx.BlockHeight < validator.MinimumBlockHeight {
		// no need to check
		return nil
	}
	return fmt.Errorf("transaction is no longer allowed since block height %d (disallowed since %d)", ctx.BlockHeight, validator.MinimumBlockHeight)
}
